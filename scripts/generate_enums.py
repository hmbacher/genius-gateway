# Generate TypeScript enums from C++ header files.
# This script parses C++ enum definitions and creates corresponding TypeScript enums.
# Can be used both as standalone script and as PlatformIO pre-action.
# Copyright (C) 2025 hmbacher
#
# All Rights Reserved. This software may be modified and distributed under
# the terms of the LGPL v3 license. See the LICENSE file for details.

import re
import os
import sys
from pathlib import Path
from typing import Dict, List, Tuple

# Import shared prebuild utilities
from prebuild_utils import is_build_task

# Check if this script should run (works for both standalone and PlatformIO execution)
if not is_build_task(['build', 'upload', 'buildfs', 'erase_upload']):
    # Skip script execution for all other tasks
    sys.exit(0)

# Import PlatformIO environment
Import("env")
project_dir = env["PROJECT_DIR"]

# ANSI color codes for terminal output
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    RESET = '\033[0m'

def parse_cpp_enum(content: str, enum_name: str) -> Tuple[Dict[str, str], Dict[str, str]]:
    """Parse a C++ enum and return values and comments."""
    
    # Pattern to match enum definition
    pattern = rf'typedef\s+enum\s+{enum_name}\s*\{{([^}}]+)\}}'
    match = re.search(pattern, content, re.DOTALL)
    
    if not match:
        return {}, {}
    
    enum_body = match.group(1)
    
    # Parse enum values
    values = {}
    comments = {}
    
    for line in enum_body.split('\n'):
        line = line.strip()
        if not line or line.startswith('//'):
            continue
            
        # Extract comment if present
        comment = ""
        if '//' in line:
            parts = line.split('//', 1)
            line = parts[0].strip()
            comment = parts[1].strip()
        
        # Remove trailing comma
        line = line.rstrip(',')
        
        if '=' in line:
            name, value = line.split('=', 1)
            name = name.strip()
            value = value.strip()
            
            # Skip MIN/MAX boundary values
            if name.endswith('_MIN') or name.endswith('_MAX'):
                continue
                
            values[name] = value
            if comment:
                comments[name] = comment
        elif line and not line.startswith('}'):
            # Enum without explicit value
            name = line.strip()
            if not name.endswith('_MIN') and not name.endswith('_MAX'):
                values[name] = None
                if comment:
                    comments[name] = comment
    
    return values, comments

def generate_typescript_enum(enum_name: str, values: Dict[str, str], comments: Dict[str, str]) -> Tuple[str, str]:
    """Generate TypeScript enum from parsed values. Returns (ts_enum_content, ts_enum_name)."""
    
    # Convert C++ enum name to TypeScript enum name
    # Only remove the trailing "_t" suffix, keep semantic prefixes like "genius_"
    clean_name = enum_name.replace('_t', '') if enum_name.endswith('_t') else enum_name
    
    # Convert to PascalCase while preserving semantic meaning
    ts_enum_name = ''.join(word.capitalize() for word in clean_name.split('_'))
    
    lines = [f"export enum {ts_enum_name} {{"]
    
    for name, value in values.items():
        # Convert C++ constant name to TypeScript
        ts_name = name
        
        # Remove common C++ enum prefixes (pattern: 2 or 3 uppercase letters followed by underscore)
        # Examples: HR_, HAE_, HSD_, CCM_, but NOT: WIFI_, USB_DEVICE_, etc.
        prefix_pattern = r'^[A-Z]{2,3}_'
        if re.match(prefix_pattern, ts_name):
            # Find the prefix and remove it
            prefix_match = re.match(prefix_pattern, ts_name)
            if prefix_match:
                ts_name = ts_name[prefix_match.end():]
        
        # Convert to PascalCase
        ts_name = ''.join(word.capitalize() for word in ts_name.split('_'))
        
        # Add comment if available
        if name in comments:
            lines.append(f"  /** {comments[name]} */")
        
        if value is not None:
            lines.append(f"  {ts_name} = {value},")
        else:
            lines.append(f"  {ts_name},")
    
    lines.append("}")
    lines.append("")
    
    return '\n'.join(lines), ts_enum_name

def create_enum_file_header():
    """Create the standard header for the enum file."""
    return [
        "// Auto-generated TypeScript enums from C++ headers",
        "// DO NOT EDIT MANUALLY - This file is generated by scripts/generate_enums.py",
        "// Run 'python scripts/generate_enums.py' to regenerate",
        ""
    ]

def write_enum_file(output_file, all_enums):
    """Write the enum content to the output file."""
    # Create output directory if it doesn't exist
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    # Write the TypeScript file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(all_enums))

def generate_enums_main(project_dir_override=None):
    """Main function to generate TypeScript enums."""
    
    if project_dir_override:
        project_dir = Path(project_dir_override)
    else:
        project_dir = Path(__file__).parent.parent
    
    src_dir = project_dir / "src"
    output_file = project_dir / "interface" / "src" / "lib" / "types" / "enums.ts"
    
    # Find all header files in src directory (including subdirectories)
    header_files = []
    for header_file in src_dir.rglob("*.h"):
        # Skip library headers (lib directory)
        if "lib" not in header_file.parts:
            header_files.append(header_file)
    
    # Start with the standard file header
    all_enums = create_enum_file_header()

    if not header_files:
        print(f"{Colors.YELLOW}⚠️ No header files found in src directory{Colors.RESET}")
        all_enums.append("// No enums found in C++ headers")
        
        write_enum_file(output_file, all_enums)
            
        print(f"\n{'-' * 60}")
        print(f"Generated empty enum file in {output_file}")
        return True  # Don't break build, just continue with empty enum file
    
    enum_count = 0
    processed_enums = []  # Track all processed enums for summary
    
    for header_file in sorted(header_files):
        relative_path = header_file.relative_to(src_dir)
        print(f"Processing {relative_path}...")
        
        try:
            with open(header_file, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            print(f"  {Colors.YELLOW}⚠️ Warning: Could not read {relative_path}: {e}{Colors.RESET}")
            continue
        
        # Find all enum definitions
        enum_pattern = r'typedef\s+enum\s+(\w+)\s*\{'
        enum_matches = re.findall(enum_pattern, content)
        
        file_enum_count = 0
        for enum_name in enum_matches:
            values, comments = parse_cpp_enum(content, enum_name)
            if values:
                ts_enum_content, ts_enum_name = generate_typescript_enum(enum_name, values, comments)
                all_enums.append(f"// From {relative_path}")
                all_enums.append(ts_enum_content)
                file_enum_count += 1
                enum_count += 1
                
                # Track the enum mapping for output
                processed_enums.append((relative_path, enum_name, ts_enum_name))
                print(f"  {Colors.GREEN}✓{Colors.RESET} {enum_name} → {ts_enum_name}")
        
        if file_enum_count == 0:
            print(f"  No enums found")
    
    write_enum_file(output_file, all_enums)
    
    print(f"\n{'-' * 60}")
    print(f"Generated {enum_count} TypeScript enum(s) in {output_file}")
    
    if processed_enums:
        print(f"\nEnum Mapping Summary:")
        print(f"{'C++ Enum':<25} → {'TypeScript Enum':<20} {'Source File'}")
        print(f"{'-' * 25}   {'-' * 20} {'-' * 30}")
        for file_path, cpp_enum, ts_enum in processed_enums:
            print(f"{cpp_enum:<25} → {ts_enum:<20} {file_path}")
    
    return True


# Execute directly as PlatformIO pre-build script (like other scripts)
print()
print("running: generate_enums.py")
print("=" * 50)
print("Generating TypeScript enums from C++ headers...")
print("=" * 50)

try:
    success = generate_enums_main(project_dir)
    print()
    if success:
        print(f"{Colors.GREEN}✓ TypeScript enums generated successfully{Colors.RESET}")
    else:
        print(f"{Colors.RED}✗ Failed to generate enums{Colors.RESET}")
        raise RuntimeError("Enum generation failed - breaking build")
    print()
except RuntimeError:
    # Re-raise RuntimeError to break the build
    raise
except Exception as e:
    print(f"{Colors.RED}✗ Error running enum generation: {e}{Colors.RESET}")
    # Break the build on unexpected errors
    raise RuntimeError(f"Enum generation failed: {e}") from e
